#!/home/vlt-os/env/bin/python

"""This file is part of Vulture 4.

Vulture 4 is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Vulture 4 is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Vulture 4.  If not, see http://www.gnu.org/licenses/.
"""
__author__ = "Th√©o Bertin"
__credits__ = []
__license__ = "GPLv3"
__version__ = "4.0.0"
__maintainer__ = "Vulture Project"
__email__ = "contact@vultureproject.org"
__doc__ = 'Update DarwinFilter objects to reflect new names and fields'

import sys
import os

# Django setup part
sys.path.append('/home/vlt-os/vulture_os')
os.environ.setdefault("DJANGO_SETTINGS_MODULE", 'vulture_os.settings')

import django
django.setup()

from system.cluster.models import Cluster
from darwin.policy.models import DarwinPolicy, FilterPolicy, DarwinFilter, DarwinBuffering, REDIS_SOCKET_PATH

if not Cluster.is_node_bootstrapped():
    sys.exit(0)

if __name__ == "__main__":

    node = Cluster.get_current_node()
    if not node:
        print("Current node not found. Maybe the cluster has not been initiated yet.")
    else:
        # Update existing filters
        for dfilter in DarwinFilter.objects.all():
            try:
                if dfilter.name == "session":
                    dfilter.name = "sess"
                    dfilter.longname = "Session"
                    dfilter.description = "Checks if a user is connected or not, by storing and querying Redis with session cookies"
                    dfilter.is_internal = True
                    dfilter.can_be_buffered = False
                    dfilter.save()
                elif dfilter.name == "dga":
                    dfilter.name = "dgad"
                    dfilter.longname = "Domain Generated by Algorithm Detection"
                    dfilter.description = "Detects the Domain Generation Algorithms (DGAs)"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = False
                    dfilter.save()
                elif dfilter.name == "anomaly":
                    dfilter.name = "unad"
                    dfilter.longname = "UNsupervised Anomaly Detection"
                    dfilter.description = "Detects abnormal connection behaviours (outliers) in network traffic"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = True
                    dfilter.save()
                elif dfilter.name == "connection":
                    dfilter.name = "conn"
                    dfilter.longname = "Connection"
                    dfilter.description = "Detects new connections between assets"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = False
                    dfilter.save()
                elif dfilter.name == "hostlookup":
                    dfilter.name = "lkup"
                    dfilter.longname = "Lookup"
                    dfilter.description = "Searches for matches in lookup files, it can be used to search for specific IPs, FQDNs, domains, URLs..."
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = False
                    dfilter.save()
                elif dfilter.name == "sofa":
                    dfilter.name = "sofa"
                    dfilter.longname = "Scan Outlier Finder and Analysis"
                    dfilter.description = "Allows finding outliers in scan results coming from network scanners"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = True
                    dfilter.save()
                elif dfilter.name == "content_inspection":
                    dfilter.longname = "deprecated in next version, please use yara instead"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = False
                    dfilter.save()
                elif dfilter.name == "tanomaly":
                    dfilter.longname = "deprecated in next version, please use unad with continuous analysis instead"
                    dfilter.is_internal = False
                    dfilter.can_be_buffered = False
                    dfilter.save()
            except Exception as e:
                print("could not update DarwinFilter '{}': {}".format(dfilter, e))



        # Create new darwin filters
        try:
            dfilter, created = DarwinFilter.objects.get_or_create(
                name="bufr",
                defaults={
                    "longname": "Buffer",
                    "description": "Caches data in Redis to request other filters with bulks at regular intervals",
                    "is_internal": True,
                    "can_be_buffered": False
                }
            )
            if created:
                print("created '{}' successfuly".format(dfilter))
            else:
                print("DarwinFilter '{}' existed already".format(dfilter))
        except Exception as e:
            print("could not create DarwinFilter 'bufr': {}".format(e))

        try:
            dfilter, created = DarwinFilter.objects.get_or_create(
                name="yara",
                defaults={
                    "longname": "Yara Engine",
                    "description": "Scans arbitrary chunks of data with the Yara engine",
                    "is_internal": False,
                    "can_be_buffered": False
                }
            )
            if created:
                print("created '{}' successfuly".format(dfilter))
            else:
                print("DarwinFilter '{}' existed already".format(dfilter))
        except Exception as e:
            print("could not create DarwinFilter 'yara': {}".format(e))



        # Update default darwin policy
        try:
            try:
                old_policy = DarwinPolicy.objects.get(name="Default darwin policy")
                print("deleting old default policy")
                old_policy.delete()
            except DarwinPolicy.DoesNotExist:
                pass

            policy, created = DarwinPolicy.objects.get_or_create(name="Internal Policy", is_internal=True)

            if not created:
                for dfilter in policy.filterpolicy_set.all():
                    dfilter.delete()

            policy.description = "Policy used to contain all internal filters"
            policy.save()

            try:
                session_type = DarwinFilter.objects.get(name="sess")
                session_filter = FilterPolicy.objects.create(
                    filter_type=session_type,
                    policy=policy,
                    config={
                        "redis_socket_path": REDIS_SOCKET_PATH
                    }
                )
            except DarwinFilter.DoesNotExist:
                print("not adding session filter to internal policy: could not get 'sess' DarwinFilter type")
        except Exception as e:
            print("could not update default darwin policy: {}".format(e))



        # Create default DGAD policy
        try:
            dgad_filter_type = DarwinFilter.objects.get(name="dgad")
            policy, created = DarwinPolicy.objects.get_or_create(
                name="Default Detect DGA",
                defaults={
                    "description": "This policy is an example of DGA detection",
                    "is_internal": False
                }
            )
            dfilter, created = FilterPolicy.objects.get_or_create(
                filter_type=dgad_filter_type,
                policy=policy,
                config = {
                    "token_map": "fdga_tokens.csv",
                    "model": "fdga.pb",
                    "max_tokens": 75
                },
                defaults={
                    "enabled": True
                }
            )
        except DarwinFilter.DoesNotExist:
            print("cannot create default dga policy, 'dgad' filter type does not exist")
        except Exception as e:
            print("error while creating dgad policy: {}".format(e))



        # Create default UNAD policy
        try:
            unad_filter_type = DarwinFilter.objects.get(name="unad")
            policy, created = DarwinPolicy.objects.get_or_create(
                name="Default Detect Network Anomaly",
                defaults={
                    "description": "This policy is an example of network anomaly detection",
                    "is_internal": False
                }
            )
            dfilter, created = FilterPolicy.objects.get_or_create(
                enabled=True,
                filter_type=unad_filter_type,
                policy=policy,
                defaults={
                    "enabled": True
                }
            )
            if created:
                # create the corresponding buffering
                DarwinBuffering.objects.create(
                    interval=300,
                    required_log_lines=10,
                    # Will be updated with next command
                    buffer_filter=None,
                    destination_filter=dfilter
                )
            DarwinPolicy.update_buffering()
        except DarwinFilter.DoesNotExist:
            print("cannot create default unad policy, 'unad' filter type does not exist")
        except Exception as e:
            print("error while creating default unad policy: {}".format(e))



        # Create default malware detection policy
        node.api_request('services.darwin.darwin.init_default_yara_policy')


        # Create default IOCs detection policy
        node.api_request("services.darwin.darwin.init_default_ioc_policy")


        # Reload all darwin configuration files
        node.api_request("services.darwin.darwin.reload_all")

        print("Done.")
