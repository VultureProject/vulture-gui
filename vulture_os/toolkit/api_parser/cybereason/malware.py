#!/home/vlt-os/env/bin/python
"""This file is part of Vulture OS.

Vulture OS is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Vulture OS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Vulture OS.  If not, see http://www.gnu.org/licenses/.
"""
__author__ = "Kevin Guillemot"
__credits__ = ["Florian Ledoux", "Antoine Lucas", "Julien Pollet", "Nicolas LanÃ§on"]
__license__ = "GPLv3"
__version__ = "4.0.0"
__maintainer__ = "Vulture OS"
__email__ = "contact@vultureproject.org"
__doc__ = 'Malware subclass: get Malware alerts'
__parser__ = 'CYBEREASON'

import json
import logging

from datetime import datetime
from django.utils import timezone

from django.conf import settings
logging.config.dictConfig(settings.LOG_SETTINGS)
logger = logging.getLogger('api_parser')

class Malware:

    MALWARE_URI = "rest/malware/query"

    def __init__(self, instance: object) -> None:
        self.frontend = getattr(instance, 'frontend')
        self.host = getattr(instance, 'host')
        self.evt_stop = getattr(instance, 'evt_stop')
        self.execute_query = getattr(instance, 'execute_query')
        self.update_lock = getattr(instance, 'update_lock')

    def get_logs(self, since: datetime, to: datetime) -> tuple[list, object, bool]:
        malware_uri = f"{self.host}/{self.MALWARE_URI}"

        query = {
            'filters': [{
                'fieldName': 'timestamp',
                'operator': 'GreaterThan',
                'values': [int(since.timestamp()) * 1000]
            },{
                'fieldName': 'timestamp',
                'operator': 'LessOrEqualsTo',
                'values': [int(to.timestamp()) * 1000]
            }],
            'limit': 1000,
            'offset': 0,
            'search': '',
            'sortDirection': 'DESC',
            'sortingFieldName': 'timestamp'
        }

        logs = []
        offset = 0
        has_more_logs = True
        last_timestamp = None
        # Get bulk of 1000 max logs
        while len(logs) < 1000 and not self.evt_stop.is_set():
            ret = self.execute_query("POST", malware_uri, query)
            if 'data' not in ret:
                has_more_logs = False
                break
            logs.extend(ret['data']['malwares'])
            if ret['status'] != 'SUCCESS' or not ret['data']['hasMoreResults']:
                has_more_logs = False
                break
            offset += 1
            query['offset'] = offset
        if logs:
            # Make sure logs are sorted by timestamps
            # ISO8601 timestamps are sortable as strings
            last_timestamp = max(log['timestamp'] for log in logs)
            last_timestamp = datetime.fromtimestamp(int(last_timestamp) / 1000, tz=timezone.utc)
        return logs, last_timestamp, has_more_logs

    def add_enrichment(self, alert: dict) -> dict:
        alert['id'] = alert['guid']
        alert['url'] = self.host
        alert['kind'] = 'malwares'
        return alert

    @staticmethod
    def format_log(log: dict) -> str:
        log['original_timestamp'] = log.pop("timestamp")
        return json.dumps(log)
